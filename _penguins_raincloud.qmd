
```{ojs}
Plot.plot(flipCoords ? rainCloudY : rainCloudX)
```


desired inputs:  
community size
year
weighted/unweighted


```{ojs}
// active inputs
viewof dimension = Inputs.select(['culmen_length_mm', 'culmen_depth_mm', 'flipper_length_mm', 'body_mass_g'], { label: 'Dimension', value: 'flipper_length_mm' })

viewof thresholds = Inputs.select([10, 20, 60], { label: 'Bins for Half Violin', value: 20 })

viewof rawDataSize = Inputs.range([10, 100], { value: 40, step: 10, label: 'Raw Data Size (%)' })

viewof rawDataOffset = Inputs.range([0, 50], { value: 5, step: 5, label: 'Raw Data Offset (%)' })

viewof showBoxPlot = Inputs.toggle({ label: 'Box Plot', value: true })

viewof boxPlotSize = Inputs.range([5, 100], { value: 15, step: 5, label: 'Box Plot Size (%)' })

viewof boxPlotOffsetFlag = Inputs.toggle({ label: 'Box Plot Offset', value: 1, values: [1, 0] })

viewof flipCoords = Inputs.toggle({ label: 'Flip Coordinate System', value: false })
```


```{ojs}
// overridden inputs here

// viewof seed = Inputs.range([1, 100], { step: 1, label: 'Raw Data Seed', value: 1 })
seed = 1







```






```{ojs}
rainCloudY = ({
  marks: [
    Plot.ruleY([Math.floor(d3.min(data.map(d => d[dimension])))]),
    halfViolinY,
    rawDataY,
    showBoxPlot ? boxPlotY : []
  ],
  facet: {
    data: data,
    x: 'species',
    marginBottom: 40
  },
  x: {
    ticks: 3,
    tickFormat: d => d < 0 ? '' : d
  },
  marginTop: 40,
  marginBottom: 60,
  marginRight: 60,
  width: 480,
  height: 640
})
```

```{ojs}
halfViolinY = Plot.areaX(
  data,
  Plot.binY(
    {
      x: 'count'
    },
    {
      y: dimension,
      fill: 'species',
      thresholds: thresholds,
      curve: 'basis'
    }
  )
)
```

```{ojs}
rawDataY = Plot.dot(
  data,
  {
		y: dimension,
	  x: jitter(data, seed),
	  fill: 'species',
		stroke: null,
		r: 1.5
	}
)
```

```{ojs}
boxPlotY = [
  Plot.ruleY(
	  data,
		Plot.groupZ(
		  {
				y: 'median'
			},
			{
				y: dimension,
				x1: -boxPlotOffset - boxPlotSize * maxTotal / 100 / 2,
				x2: -boxPlotOffset + boxPlotSize * maxTotal / 100 / 2,
				strokeWidth: 2,
        stroke: '#333333'
			}
		)
	),
  Plot.rectY(
    data,
    Plot.groupZ(
      {
        y1: lowerQuartile,
        y2: upperQuartile
      },
      {
        y: dimension,
				x1: -boxPlotOffset - boxPlotSize * maxTotal / 100 / 2,
				x2: -boxPlotOffset + boxPlotSize * maxTotal / 100 / 2,
				stroke: '#333333'
      }
    )
  ),
  Plot.ruleX(
    data,
    Plot.groupX(
      {
        y1: lowerWhisker,
        y2: lowerQuartile
      },
      {
        y: dimension,
				x: -boxPlotOffset,
        stroke: '#333333'
      }
    )
  ),
  Plot.ruleX(
    data,
    Plot.groupX(
      {
        y1: upperQuartile,
        y2: upperWhisker
      },
      {
        y: dimension,
				x: -boxPlotOffset,
        stroke: '#333333'
      }
    )
  )  
]
```

```{ojs}
rainCloudX = ({
  marks: [
    Plot.ruleX([Math.floor(d3.min(data.map(d => d[dimension])))]),
    halfViolinX,
    rawDataX,
    showBoxPlot ? boxPlotX : []
  ],
  facet: {
    data: data,
    y: 'species',
    marginRight: 80
  },
  y: {
    ticks: 3,
    tickFormat: d => d < 0 ? '' : d 
  },
  marginBottom: 40,
  width: 640,
  height: 480
})
```

```{ojs}
halfViolinX = Plot.areaY(
  data,
  Plot.binX(
    {
      y: 'count'
    },
    {
      x: dimension,
      fill: 'species',
      thresholds: thresholds,
      curve: 'basis'
    }
  )
)
```


```{ojs}
rawDataX = Plot.dot(
  data,
  {
		x: dimension,
	  y: jitter(data, seed),
	  fill: 'species',
		stroke: null,
		r: 1.5
	}
)
```

```{ojs}
boxPlotX = [
  Plot.ruleX(
	  data,
		Plot.groupZ(
		  {
				x: 'median'
			},
			{
				x: dimension,
				y1: -boxPlotOffset - boxPlotSize * maxTotal / 100 / 2,
				y2: -boxPlotOffset + boxPlotSize * maxTotal / 100 / 2,
				strokeWidth: 2,
        stroke: '#333333'
			}
		)
	),
  Plot.rectX(
    data,
    Plot.groupZ(
      {
        x1: lowerQuartile,
        x2: upperQuartile
      },
      {
        x: dimension,
				y1: -boxPlotOffset - boxPlotSize * maxTotal / 100 / 2,
				y2: -boxPlotOffset + boxPlotSize * maxTotal / 100 / 2,
				stroke: '#333333'
      }
    )
  ),
  Plot.ruleY(
    data,
    Plot.groupY(
      {
        x1: lowerWhisker,
        x2: lowerQuartile
      },
      {
        x: dimension,
				y: -boxPlotOffset,
        stroke: '#333333'
      }
    )
  ),
  Plot.ruleY(
    data,
    Plot.groupY(
      {
        x1: upperQuartile,
        x2: upperWhisker
      },
      {
        x: dimension,
				y: -boxPlotOffset,
        stroke: '#333333'
      }
    )
  )  
]

```

```{ojs}
//| echo: false
// appendix

boxPlotOffset = boxPlotOffsetFlag * (rawDataOffset + rawDataSize / 2) * maxTotal / 100

upperWhisker = d => Math.min(d3.max(d), upperQuartile(d) + 1.5 * iqr(d))

lowerWhisker = d => Math.max(d3.min(d), lowerQuartile(d) - 1.5 * iqr(d))

iqr = d => upperQuartile(d) - lowerQuartile(d)

upperQuartile = d => d3.quantile(d, 0.75)

lowerQuartile = d => d3.quantile(d, 0.25)

jitter = (data, seed) => {
  const rng = seedrandom(seed);
  return data.map(() => -(rng() * rawDataSize + rawDataOffset) * maxTotal / 100);
}

maxTotal = d3.max(
  Array.from(
    d3
    .group(data, d => d.species)
    .values()
  )
  .flatMap(g => bins(g.map(d => d[dimension])))
  .map(bin => bin.length)
)

bins = d3
  .bin()
  .domain(d3.extent(data, d => d[dimension]))
  .thresholds(thresholds)

data = FileAttachment("data/raw/palmer_penguins.csv").csv({ typed: true })

seedrandom = require('seedrandom')
```